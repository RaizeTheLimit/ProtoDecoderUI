<!DOCTYPE html>
<!-- Doc at https://developer.mozilla.org/fr/docs/Web/HTML/Quirks_Mode_and_Standards_Mode -->
<!-- Themes and more credits https://github.com/Dani-404 -->
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <link rel="icon" href="images/favicon.png" />
    <link rel="apple-touch-icon" href="images/favicon.png" />
    <title>ProtoDecoderUI</title>
    <link rel="stylesheet" type="text/css" href="css/style.css" />
    <script
      src="https://code.jquery.com/jquery-3.4.1.min.js"
      integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo="
      crossorigin="anonymous"
    ></script>
    <link
      rel="stylesheet"
      type="text/css"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/css/bootstrap.min.css"
    />
    <script
      type="text/javascript"
      src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.bundle.min.js"
    ></script>
    <script src="https://kit.fontawesome.com/13b744953d.js"></script>
    <script src="/socket.io/socket.io.js"></script>

    <script src="json-viewer/jquery.json-viewer.js"></script>
    <link
      href="json-viewer/jquery.json-viewer.css"
      type="text/css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4"></script>
  </head>
  <body class="p-2">
    <div class="container-fluid">
      <div class="row">
        <div class="col" style="padding-bottom: 40px">
          <div class="card">
            <h4 class="card-header">
              <div class="title-proto">ProtoDecoderUI</div>
              <div class="icons">
                <i class="fas fa-sun" id="darkmode-button"></i>
                <i class="fas fa-play" id="play-button"></i>
                <i class="fas fa-pause" id="pause-button"></i>
                <i class="fas fa-trash" id="clear-button"></i>
                <i class="fas fa-sign-out-alt" id="logout-button" style="display: none;" title="Logout"></i>
              </div>
            </h4>
            <div class="card-body">
              <div class="row">
                <div class="col-md-12">Filters</div>
                <div class="col-md-8 col-sm-6">
                  <label for="instance-filter">Instance</label>
                  <input
                    type="text"
                    id="instance-filter"
                    placeholder="Instance name"
                  />
                  <label for="instance-filter-dropdown">Found Instances:</label>
                  <select id="instance-filter-dropdown">
                    <option value="">All Instances</option>
                  </select>
                </div>
                <div class="col-md-4 col-sm-6">
                  <label for="maxlogs" style="display: inline-block; margin-right: 5px;">Max Logs</label>
                  <select
                    id="maxlogs"
                    style="padding: 3px; width: auto; min-width: 100px;"
                  ></select>
                </div>
              </div>
              <div class="row" style="margin-top: 10px;">
                <div class="col-md-6 col-sm-12">
                  <!-- Enhanced Method Filter Panel (injected by JavaScript) -->
                  <div id="method-filter-wrapper"></div>
                </div>
                <div class="col-md-6 col-sm-12">
                  <!-- Statistics Panel (injected by JavaScript) -->
                  <div id="statistics-wrapper"></div>
                </div>
              </div>
              <table
                id="data_socket"
                class="table table-striped table-hover table-bordered rounded-lg"
                style="width: 100%; margin-top: 10px"
              >
                <thead>
                  <tr>
                    <th class="mobile-hide">Instance</th>
                    <th>Method</th>
                    <th>Method Name</th>
                    <th class="mobile-hide">Sended Data</th>
                    <th class="mobile-hide">Received Data</th>
                    <th class="mobile-only">Req</th>
                    <th class="mobile-only">Res</th>
                    <th class="mobile-only">DL</th>
                  </tr>
                </thead>
                <tbody></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="modal-detail" class="modal" tabindex="-1" role="dialog">
      <div
        class="modal-dialog"
        style="max-width: 80% !important"
        role="document"
      >
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title">
              Method id: <span class="method-id"></span>
            </h5>
            <button
              type="button"
              class="close"
              data-dismiss="modal"
              aria-label="Close"
            >
              <span aria-hidden="true">&times;</span>
            </button>
          </div>
          <div class="modal-body">
            <p>Method name: <span class="method-name"></span></p>
            <p>Request data (Sent to server): <small style="color: #666;">(Click to copy)</small></p>
            <pre class="method-data-incoming clickable-data" style="cursor: pointer; position: relative;"></pre>
            <p>Response data (Received from server): <small style="color: #666;">(Click to copy)</small></p>
            <pre class="method-data-outgoing clickable-data" style="cursor: pointer; position: relative;"></pre>
          </div>
          <div class="modal-footer">
            <div style="margin-right: auto; display: flex; align-items: center;">
              <label style="margin: 0 8px 0 0; font-weight: normal;">Format:</label>
              <select id="export-format-modal" style="padding: 3px;">
                <option value="json">JSON</option>
                <option value="yaml">YAML</option>
              </select>
            </div>
            <button
              type="button"
              class="btn btn-primary"
              id="download-incoming"
            >
              <i class="fas fa-download"></i> Download Request
            </button>
            <button
              type="button"
              class="btn btn-primary"
              id="download-outgoing"
            >
              <i class="fas fa-download"></i> Download Response
            </button>
            <button
              type="button"
              class="btn btn-success"
              id="download-combined"
            >
              <i class="fas fa-download"></i> Download Both
            </button>
            <button
              type="button"
              class="btn btn-secondary"
              data-dismiss="modal"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    </div>
    <div class="footer">
      <a href="https://github.com/Dani-404" target="_blank"
        >Themes and more credits (Daniel)</a
      >
      -
      <a href="https://github.com/RaizeTheLimit/ProtoDecoderUI" target="_blank"
        >ProtoDecoderUI</a
      >
      -
      <a href="https://github.com/Furtif" target="_blank">--=FurtiFâ„¢=--</a>
      Â©2016-2024
    </div>
    <script>
      class IncomingMessage {
        constructor(id, obj) {
          this.id = id;
          this.data = obj.data;
          this.identifier = obj.identifier;
          this.methodId = obj.methodId;
          this.methodName = obj.methodName;
          this.responseHtmlElement = null;
          this.responseStatusElement = null;
          this.response = null;
          this.timestamp = Date.now(); // First-seen timestamp
        }
        setResponse(obj) {
          this.response = obj;
        }
      }

      // =========================
      // Session Tracking State
      // =========================
      const rowFirstSeen = new Map(); // row ID -> first-seen timestamp
      const methodCounts = new Map(); // method ID -> count (session only)
      let allowedMethods = new Set(); // Set of allowed method IDs (for filtering)
      let knownMethods = new Set(); // All discovered methods (persistent)
      let methodMap = new Map(); // method ID -> method name mapping
      let isUserTyping = false;
      let globalIsComposing = false;
      let showSeenMethodsOnly = false; // Toggle: show all methods vs. seen only
      var STATE = 0;
      setStateOnButtons();
      var incoming = io.connect("/incoming"),
        outgoing = io.connect("/outgoing");
      let incomingProtocolId = 0;
      let maxLogs = 100,
        darkMode = false;
      let maxLogsValue = [1000, 500, 300, 200, 100, 50];
      resetLogsValue();
      let messages = [];
      let foundInstances = [];
      let instanceFilter = "";
      let exportFormat = "json"; // Default export format
      let sessionStartTime = Date.now();

      // =========================
      // Utility Functions
      // =========================
      function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
      }

      function fmtStamp(ms) {
        return new Date(ms).toISOString().replace(/[:-]/g, "").slice(0, 15);
      }

      function downloadFile(data, filename, format = "json") {
        let content, mimeType;
        if (format === "yaml") {
          try {
            content = jsyaml.dump(data, { noRefs: true });
            mimeType = "text/yaml;charset=utf-8";
          } catch (e) {
            console.error("YAML conversion failed:", e);
            showToast("YAML export failed, using JSON instead", true);
            content = JSON.stringify(data, null, 2);
            mimeType = "application/json";
            filename = filename.replace(/\.yaml$/, ".json");
          }
        } else {
          content = JSON.stringify(data, null, 2);
          mimeType = "application/json";
        }
        const blob = new Blob([content], { type: mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function downloadJSON(data, filename) {
        downloadFile(data, filename, "json");
      }

      function showToast(message, isError = false) {
        const bgColor = isError ? '#dc3545' : '#28a745';
        const toast = $(`<div style="position: fixed; bottom: 20px; right: 20px; background: ${bgColor}; color: white; padding: 12px 20px; border-radius: 5px; font-size: 14px; z-index: 9999; box-shadow: 0 2px 10px rgba(0,0,0,0.2);">${message}</div>`);
        $('body').append(toast);
        toast.hide().fadeIn(300);
        setTimeout(function() {
          toast.fadeOut(300, function() {
            toast.remove();
          });
        }, 2000);
      }

      function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(function() {
          showToast('Copied to clipboard!');
        }).catch(function(err) {
          console.error('Failed to copy: ', err);
          showToast('Failed to copy to clipboard', true);
        });
      }
      incoming.on("protos", function (data) {
        if (foundInstances.indexOf(data.identifier) === -1) {
          foundInstances.push(data.identifier);
          appendFoundName(data.identifier);
        }

        // Track methods (only update if not already loaded from server)
        const methodId = String(data.methodId);
        if (!methodMap.has(methodId)) {
          methodMap.set(methodId, data.methodName);
          knownMethods.add(methodId);
          saveMethodMap();
          saveKnownMethods();

          // Auto-check new methods by default
          if (!allowedMethods.has(methodId)) {
            allowedMethods.add(methodId);
            saveAllowedMethods();
          }
        }

        if (STATE !== 1) {
          return;
        }
        if (instanceFilter !== "" && data.identifier !== instanceFilter) {
          return;
        }
        // Use new allowedMethods set for filtering
        if (allowedMethods.size > 0 && !allowedMethods.has(methodId)) {
          return;
        }
        if (typeof data.error !== "undefined") {
          console.error(data.error);
        } else {
          incomingProtocolId++;
          const message = new IncomingMessage(incomingProtocolId, data);
          messages.push(message);

          // Track first-seen and counts
          const rowId = String(incomingProtocolId);
          if (!rowFirstSeen.has(rowId)) {
            rowFirstSeen.set(rowId, message.timestamp);
            methodCounts.set(methodId, (methodCounts.get(methodId) || 0) + 1);
          }

          const tr = document.createElement("tr");
          tr.setAttribute("id", message.id);
          tr.setAttribute("data-method-id", methodId);

          const tdInstance = document.createElement("td");
          tdInstance.classList.add("mobile-hide");
          tdInstance.innerText = message.identifier;
          tr.appendChild(tdInstance);

          const tdMethodId = document.createElement("td");
          tdMethodId.innerText = message.methodId;
          tdMethodId.classList.add("important");
          tr.appendChild(tdMethodId);

          const tdMethodName = document.createElement("td");
          tdMethodName.innerText = message.methodName;
          tr.appendChild(tdMethodName);

          const tdData = document.createElement("td");
          tdData.classList.add("mobile-hide");
          tdData.innerHTML = objectToReadable(message.data);
          tr.appendChild(tdData);

          const tdResponse = document.createElement("td");
          tdResponse.classList.add("mobile-hide");
          tdResponse.innerText = "Waiting data...";
          message.responseHtmlElement = tdResponse;
          tr.appendChild(tdResponse);

          const tdReqStatus = document.createElement("td");
          tdReqStatus.classList.add("mobile-only", "text-center");
          const reqCopyBtn = document.createElement("button");
          reqCopyBtn.innerHTML = '<i class="fas fa-copy"></i>';
          reqCopyBtn.style.cssText = "padding: 4px; font-size: 14px; border: none; background: transparent; color: #007bff; cursor: pointer;";
          reqCopyBtn.onclick = function(e) {
            e.stopPropagation();
            const jsonStr = JSON.stringify(message.data, null, 2);
            copyToClipboard(jsonStr);
          };
          tdReqStatus.appendChild(reqCopyBtn);
          tr.appendChild(tdReqStatus);

          const tdResStatus = document.createElement("td");
          tdResStatus.classList.add("mobile-only", "text-center");
          tdResStatus.innerHTML = '<span style="color: red;">âœ—</span>';
          message.responseStatusElement = tdResStatus;
          tr.appendChild(tdResStatus);

          const tdDownload = document.createElement("td");
          tdDownload.classList.add("mobile-only", "text-center");
          const downloadBtn = document.createElement("button");
          downloadBtn.innerHTML = '<i class="fas fa-download"></i>';
          downloadBtn.style.cssText = "padding: 4px; font-size: 14px; border: none; background: transparent; color: #28a745; cursor: pointer;";
          downloadBtn.onclick = function(e) {
            e.stopPropagation(); // Prevent row click
            const ext = exportFormat === "yaml" ? "yaml" : "json";
            const timestamp = fmtStamp(message.timestamp);
            const filename = `${message.methodName}_${timestamp}_${message.id}_combined.${ext}`;
            const combinedData = {
              identifier: message.identifier,
              methodId: message.methodId,
              methodName: message.methodName,
              request: message.data,
              response: message.response ? message.response.data : null
            };
            downloadFile(combinedData, filename, exportFormat);
          };
          tdDownload.appendChild(downloadBtn);
          tr.appendChild(tdDownload);

          $("#data_socket tbody").prepend(tr);
          if ($("#data_socket tbody").children().length > maxLogs)
            $("#data_socket tbody").children().last().remove();
        }
      });
      outgoing.on("protos", function (data) {
        if (foundInstances.indexOf(data.identifier) === -1) {
          foundInstances.push(data.identifier);
          appendFoundName(data.identifier);
        }

        // Track methods (only update if not already loaded from server)
        const methodId = String(data.methodId);
        if (!methodMap.has(methodId)) {
          methodMap.set(methodId, data.methodName);
          knownMethods.add(methodId);
          saveMethodMap();
          saveKnownMethods();

          // Auto-check new methods by default
          if (!allowedMethods.has(methodId)) {
            allowedMethods.add(methodId);
            saveAllowedMethods();
          }
        }

        if (STATE !== 1) {
          return;
        }
        // Use new allowedMethods set for filtering
        if (allowedMethods.size > 0 && !allowedMethods.has(methodId)) {
          return;
        }
        if (instanceFilter !== "" && data.identifier !== instanceFilter) {
          return;
        }
        if (typeof data.error !== "undefined") {
          console.error(data.error);
        } else {
          const incomingMessage = messages.filter(
            (message) =>
              message.methodId == data.methodId && message.response == null
          )[0];
          if (incomingMessage == null)
            return console.error(
              `Impossible to get incoming message for response: [${data.methodId}] ${data.methodName}.`
            );
          incomingMessage.response = data;
          incomingMessage.responseHtmlElement.innerHTML = objectToReadable(
            data.data
          );
          if (incomingMessage.responseStatusElement) {
            incomingMessage.responseStatusElement.innerHTML = '';
            const resCopyBtn = document.createElement("button");
            resCopyBtn.innerHTML = '<i class="fas fa-copy"></i>';
            resCopyBtn.style.cssText = "padding: 4px; font-size: 14px; border: none; background: transparent; color: #007bff; cursor: pointer;";
            resCopyBtn.onclick = function(e) {
              e.stopPropagation();
              const jsonStr = JSON.stringify(data.data, null, 2);
              copyToClipboard(jsonStr);
            };
            incomingMessage.responseStatusElement.appendChild(resCopyBtn);
          }
        }
      });
      let currentModalMessage = null;
      $("#data_socket tbody").on("click", "tr", function () {
        const message = messages.filter((msg) => msg.id == $(this)[0].id)[0];
        if (message == null) return;
        currentModalMessage = message;
        $("#modal-detail").find(".method-id").html(message.methodId);
        $("#modal-detail").find(".method-name").html(message.methodName);
        $("#modal-detail")
          .find(".method-data-incoming")
          .jsonViewer(message.data);
        $("#modal-detail")
          .find(".method-data-outgoing")
          .jsonViewer(message.response.data);
        $("#modal-detail").modal();
      });
      $("#download-incoming").click(function () {
        if (!currentModalMessage) return;
        const format = $("#export-format-modal").val() || exportFormat;
        const ext = format === "yaml" ? "yaml" : "json";
        const timestamp = fmtStamp(currentModalMessage.timestamp);
        const filename = `${currentModalMessage.methodName}_${timestamp}_${currentModalMessage.id}_req.${ext}`;
        downloadFile(currentModalMessage.data, filename, format);
      });

      $("#download-outgoing").click(function () {
        if (!currentModalMessage || !currentModalMessage.response) return;
        const format = $("#export-format-modal").val() || exportFormat;
        const ext = format === "yaml" ? "yaml" : "json";
        const timestamp = fmtStamp(currentModalMessage.timestamp);
        const filename = `${currentModalMessage.methodName}_${timestamp}_${currentModalMessage.id}_resp.${ext}`;
        downloadFile(currentModalMessage.response.data, filename, format);
      });

      $("#download-combined").click(function () {
        if (!currentModalMessage) return;
        const format = $("#export-format-modal").val() || exportFormat;
        const ext = format === "yaml" ? "yaml" : "json";
        const timestamp = fmtStamp(currentModalMessage.timestamp);
        const filename = `${currentModalMessage.methodName}_${timestamp}_${currentModalMessage.id}_combined.${ext}`;
        const combinedData = {
          identifier: currentModalMessage.identifier,
          methodId: currentModalMessage.methodId,
          methodName: currentModalMessage.methodName,
          request: currentModalMessage.data,
          response: currentModalMessage.response ? currentModalMessage.response.data : null
        };
        downloadFile(combinedData, filename, format);
      });

      $(document).on('click', '.method-data-incoming', function(e) {
        if (currentModalMessage && currentModalMessage.data) {
          const jsonStr = JSON.stringify(currentModalMessage.data, null, 2);
          copyToClipboard(jsonStr);
        }
      });

      $(document).on('click', '.method-data-outgoing', function(e) {
        if (currentModalMessage && currentModalMessage.response && currentModalMessage.response.data) {
          const jsonStr = JSON.stringify(currentModalMessage.response.data, null, 2);
          copyToClipboard(jsonStr);
        }
      });

      $("#darkmode-button").click(function () {
        if (document.body.classList.contains("dark")) {
          document.body.classList.remove("dark");
          $(this).removeClass("fa-moon");
          $(this).addClass("fa-sun");
          darkMode = false;
          storeSettings();
        } else {
          document.body.classList.add("dark");
          $(this).removeClass("fa-sun");
          $(this).addClass("fa-moon");
          darkMode = true;
          storeSettings();
        }
      });
      $("#play-button").click(function () {
        STATE = 1;
        setStateOnButtons();
        storeSettings();
      });
      $("#pause-button").click(function () {
        STATE = 0;
        setStateOnButtons();
        storeSettings();
      });
      $("#clear-button").click(function () {
        clearTable();
      });
      $("#logout-button").click(async function () {
        if (confirm("Are you sure you want to logout?")) {
          try {
            await fetch("/auth/logout", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
            });
            window.location.href = "/login";
          } catch (error) {
            console.error("Logout error:", error);
            alert("Failed to logout. Please try again.");
          }
        }
      });
      function clearTable() {
        $("#data_socket tbody tr").remove();
        messages = [];
      }
      function resetLogsValue() {
        $("#maxlogs option").each((i, el) => {
          el.remove();
        });
        maxLogsValue.sort((a, b) => a - b);
        for (let i in maxLogsValue) {
          const option = document.createElement("option");
          option.innerText = maxLogsValue[i];

          if (maxLogsValue[i] == maxLogs) option.selected = true;

          $("#maxlogs").append(option);
        }
        const otherOption = document.createElement("option");
        otherOption.innerText = "Other";
        $("#maxlogs").append(otherOption);
      }
      function setLogValue(val) {
        maxLogs = val;
        if (!maxLogsValue.includes(val)) {
          maxLogsValue.push(val);
          resetLogsValue();
        }
        clearTable();
        storeSettings();
      }
      function setStateOnButtons() {
        let id = "";
        let idDisabled = "";
        switch (STATE) {
          case 0:
            id = "play-button";
            idDisabled = "pause-button";
            break;
          case 1:
            id = "pause-button";
            idDisabled = "play-button";
            break;
        }
        $("#" + id).css("opacity", 1);
        $("#" + id).addClass("running");
        $("#" + idDisabled).css("opacity", 0.5);
        $("#" + idDisabled).removeClass("running");
      }
      function appendFoundName(name) {
        const option = document.createElement("option");
        option.setAttribute("name", name);
        option.textContent = name;
        $("#instance-filter-dropdown").append(option);
        if (instanceFilter == name) $("#instance-filter-dropdown").val(name);
      }
      function objectToReadable(object) {
        let dataStrings = [];
        let numberOfRows = 0;
        for (let key in object) {
          if (numberOfRows >= 10) {
            dataStrings.push("...");
            break;
          }
          let value;
          if (typeof object[key] === "object") {
            value = JSON.stringify(object[key]);
          } else {
            value = object[key];
          }
          if (value.length > 60) {
            value =
              value.substr(0, 10) + "..." + value.substr(value.length - 10);
          }
          numberOfRows++;
          dataStrings.push(`${key}: ${value}`);
        }
        return dataStrings.join("<br>");
      }
      $("#instance-filter-dropdown").change(function () {
        $("#instance-filter").val($(this).val());
        $("#instance-filter").keyup();
      });
      $("#instance-filter").keyup(function () {
        clearTable();
        instanceFilter = $(this).val();
        storeSettings();
      });

      // Export format modal selector
      $("#export-format-modal").change(function () {
        exportFormat = $(this).val();
        storeSettings();
      });
      $("#maxlogs").on("change", function () {
        if (this.value == "Other") {
          let val = prompt("Please enter the value", "");
          if (val == null || val.length == 0 || isNaN(parseInt(val)))
            return alert("Invalid value!");
          setLogValue(parseInt(val));
          return;
        }
        if (isNaN(this.value)) return;
        setLogValue(parseInt(this.value));
      });
      function loadSettings() {
        let settingsJson = localStorage.getItem("settings");
        if (settingsJson !== null) {
          const settings = JSON.parse(settingsJson);
          STATE = parseInt(settings["STATE"] || 0);
          instanceFilter = settings["instanceFilter"] || "";

          if (settings["maxLogs"] != null && !isNaN(parseInt(settings["maxLogs"]))) {
            setLogValue(parseInt(settings["maxLogs"]));
          }
          if(settings["darkMode"] != null && JSON.parse(settings["darkMode"])) {
            darkMode = true;
            document.body.classList.add("dark");
          }
          if (settings["exportFormat"]) {
            exportFormat = settings["exportFormat"];
            $("#export-format-modal").val(exportFormat);
          }
          if (settings["showSeenMethodsOnly"] != null) {
            showSeenMethodsOnly = settings["showSeenMethodsOnly"];
          }

          if (STATE === 1) {
            $("#play-button").click();
          }
          $("#instance-filter").val(instanceFilter);
        }
        $("#maxlogs").val(maxLogs);
      }

      // Load persistent method tracking data
      function loadAllowedMethods() {
        try {
          const data = JSON.parse(localStorage.getItem("allowedMethods") || "[]");
          return new Set(data.map(String));
        } catch {
          return new Set();
        }
      }

      function saveAllowedMethods() {
        localStorage.setItem("allowedMethods", JSON.stringify([...allowedMethods]));
      }

      function loadKnownMethods() {
        try {
          const data = JSON.parse(localStorage.getItem("knownMethods") || "[]");
          return new Set(data.map(String));
        } catch {
          return new Set();
        }
      }

      function saveKnownMethods() {
        localStorage.setItem("knownMethods", JSON.stringify([...knownMethods]));
      }

      function loadMethodMap() {
        try {
          const data = JSON.parse(localStorage.getItem("methodMap") || "{}");
          return new Map(Object.entries(data));
        } catch {
          return new Map();
        }
      }

      function saveMethodMap() {
        localStorage.setItem("methodMap", JSON.stringify(Object.fromEntries(methodMap)));
      }

      // =========================
      // Load Complete Method List from Server
      // =========================
      async function loadAllMethodsFromServer() {
        try {
          const response = await fetch('/api/methods');
          if (!response.ok) throw new Error('Failed to fetch methods');

          const allMethods = await response.json();

          console.log(`ðŸ“‹ Loaded ${allMethods.length} methods from server`);

          // Populate methodMap with all available methods
          allMethods.forEach(method => {
            methodMap.set(method.id, method.cleanName);
            knownMethods.add(method.id);

            // Auto-check all methods by default
            if (!allowedMethods.has(method.id)) {
              allowedMethods.add(method.id);
            }
          });

          // Save to localStorage
          saveMethodMap();
          saveKnownMethods();
          saveAllowedMethods();

          // Refresh UI
          renderMethodFilterPanel();

          return true;
        } catch (error) {
          console.error('âŒ Failed to load methods from server:', error);
          showToast('Failed to load complete method list', true);
          return false;
        }
      }

      // Initialize from localStorage
      allowedMethods = loadAllowedMethods();
      knownMethods = loadKnownMethods();
      methodMap = loadMethodMap();

      loadSettings();

      // Check if authentication is enabled and show logout button
      fetch("/auth/status")
        .then(response => response.json())
        .then(data => {
          if (data.authRequired) {
            document.getElementById("logout-button").style.display = "inline-block";
          }
        })
        .catch(error => {
          console.log("Could not check auth status:", error);
        });

      function storeSettings() {
        localStorage.setItem(
          "settings",
          JSON.stringify({
            STATE: STATE,
            instanceFilter: instanceFilter,
            maxLogs: maxLogs,
            darkMode: darkMode,
            exportFormat: exportFormat,
            showSeenMethodsOnly: showSeenMethodsOnly
          })
        );
      }

      // =========================
      // Input Detection (Smart UI Updates)
      // =========================
      function isEditableTarget(el) {
        if (!el) return false;
        const tag = el.tagName;
        if (tag === "TEXTAREA") return true;
        if (tag === "INPUT") {
          const t = (el.type || "text").toLowerCase();
          return ["text", "search", "email", "url", "tel", "password", "number", ""].includes(t);
        }
        return !!el.isContentEditable;
      }

      function checkUserTyping() {
        const ae = document.activeElement;
        return globalIsComposing || isEditableTarget(ae);
      }

      document.addEventListener("compositionstart", (e) => {
        if (isEditableTarget(e.target)) globalIsComposing = true;
      }, true);

      document.addEventListener("compositionend", (e) => {
        if (isEditableTarget(e.target)) globalIsComposing = false;
      }, true);

      // =========================
      // Row Highlighting
      // =========================
      function updateRowHighlighting() {
        document.querySelectorAll("#data_socket tbody tr").forEach((row) => {
          const methodId = row.getAttribute("data-method-id");
          if (methodId) {
            const isAllowed = allowedMethods.has(methodId);
            row.classList.toggle("proto-disabled", !isAllowed);
          }
        });
      }

      // =========================
      // Statistics Panel
      // =========================
      function renderStatisticsPanel() {
        const wrapper = document.getElementById("statistics-wrapper");
        if (!wrapper) return;

        const totalMethodsAvailable = methodMap.size;  // From server (complete list)
        const totalMethodsSeen = methodCounts.size;    // From traffic (this session)
        const totalProtos = messages.length;
        const uptime = Math.floor((Date.now() - sessionStartTime) / 1000);
        const uptimeStr = `${Math.floor(uptime / 60)}m ${uptime % 60}s`;

        wrapper.innerHTML = `
          <div class="statistics-panel">
            <div class="stat-header">
              <strong>Session Statistics</strong>
              <button id="stats-toggle" class="stat-toggle">â–¼</button>
            </div>
            <div id="stats-content" class="stat-content">
              <div class="stat-item"><span class="stat-label">Session Uptime:</span> <span class="stat-value">${uptimeStr}</span></div>
              <div class="stat-item"><span class="stat-label">Methods Available:</span> <span class="stat-value">${totalMethodsAvailable}</span></div>
              <div class="stat-item"><span class="stat-label">Methods Seen:</span> <span class="stat-value">${totalMethodsSeen}</span></div>
              <div class="stat-item"><span class="stat-label">Total Protos:</span> <span class="stat-value">${totalProtos}</span></div>
            </div>
          </div>
        `;

        // Toggle functionality
        $("#stats-toggle").off("click").on("click", function() {
          const content = $("#stats-content");
          const btn = $(this);
          if (content.is(":visible")) {
            content.slideUp();
            btn.text("â–²");
          } else {
            content.slideDown();
            btn.text("â–¼");
          }
        });
      }

      // =========================
      // Enhanced Method Filter Panel
      // =========================
      function renderMethodFilterPanel() {
        const wrapper = document.getElementById("method-filter-wrapper");
        if (!wrapper) return;

        const savedSearch = localStorage.getItem("methodFilterSearch") || "";

        wrapper.innerHTML = `
          <div class="method-filter-panel">
            <div class="filter-header">
              <strong>Method Filter</strong>
              <small style="margin-left: 10px; opacity: 0.7;">(Uncheck to skip export)</small>

              <button id="seen-only-toggle" class="filter-toggle" style="margin-left: auto; margin-right: 5px;" title="${showSeenMethodsOnly ? 'Showing only methods seen in traffic (click to show all)' : 'Showing all available methods (click to show seen only)'}">
                <i class="fas ${showSeenMethodsOnly ? 'fa-eye' : 'fa-list'}"></i>
              </button>

              <button id="refresh-methods-btn" class="filter-toggle" style="margin-right: 5px;" title="Reload methods from server">
                <i class="fas fa-sync-alt"></i>
              </button>
              <button id="filter-toggle" class="filter-toggle">â–¼</button>
            </div>
            <div id="filter-content" class="filter-content">
              <input type="text" id="method-search" class="method-search" placeholder="Search Method ID or Name..." value="${savedSearch}" />
              <div id="method-list" class="method-list"></div>
            </div>
          </div>
        `;

        // Render method list
        renderMethodList(savedSearch);

        // Search handler with IME support
        let searchIsComposing = false;
        $("#method-search").on("compositionstart", function() {
          searchIsComposing = true;
        });
        $("#method-search").on("compositionend", function() {
          searchIsComposing = false;
          const query = $(this).val();
          localStorage.setItem("methodFilterSearch", query);
          renderMethodList(query);
        });
        $("#method-search").on("input", function() {
          if (!searchIsComposing) {
            const query = $(this).val();
            localStorage.setItem("methodFilterSearch", query);
            renderMethodList(query);
          }
        });

        // Refresh methods button
        $("#refresh-methods-btn").off("click").on("click", async function() {
          const icon = $(this).find("i");
          icon.addClass("fa-spin");
          await loadAllMethodsFromServer();
          icon.removeClass("fa-spin");
          showToast('Methods refreshed from server');
        });

        // Seen-only toggle handler
        $("#seen-only-toggle").off("click").on("click", function() {
          showSeenMethodsOnly = !showSeenMethodsOnly;
          storeSettings();

          // Update button icon and tooltip
          const icon = $(this).find("i");
          icon.removeClass("fa-eye fa-list");
          icon.addClass(showSeenMethodsOnly ? "fa-eye" : "fa-list");
          $(this).attr("title", showSeenMethodsOnly
            ? "Showing only methods seen in traffic (click to show all)"
            : "Showing all available methods (click to show seen only)");

          // Re-render the method list with new filter
          const searchQuery = $("#method-search").val() || "";
          renderMethodList(searchQuery);

          // Show toast to indicate what's being displayed
          if (showSeenMethodsOnly) {
            showToast(`Showing ${methodCounts.size} methods seen in traffic`);
          } else {
            showToast(`Showing all ${methodMap.size} available methods`);
          }
        });

        // Toggle functionality
        $("#filter-toggle").off("click").on("click", function() {
          const content = $("#filter-content");
          const btn = $(this);
          if (content.is(":visible")) {
            content.slideUp();
            btn.text("â–²");
          } else {
            content.slideDown();
            btn.text("â–¼");
          }
        });
      }

      function renderMethodList(filterText = "") {
        const listEl = document.getElementById("method-list");
        if (!listEl) return;

        const filter = filterText.toLowerCase();
        const entries = Array.from(methodMap.entries())
          .filter(([id, name]) => {
            // If "Seen Only" is enabled, only show methods that have been seen
            if (showSeenMethodsOnly && !methodCounts.has(id)) {
              return false;
            }

            // Apply search filter
            if (!filter) return true;
            return id.includes(filter) || name.toLowerCase().includes(filter);
          })
          .sort((a, b) => parseInt(a[0]) - parseInt(b[0]));

        listEl.innerHTML = "";

        // Show message if no methods match
        if (entries.length === 0) {
          const emptyMsg = document.createElement("div");
          emptyMsg.style.cssText = "padding: 20px; text-align: center; opacity: 0.6; font-style: italic;";
          emptyMsg.textContent = showSeenMethodsOnly
            ? "No methods seen in traffic yet"
            : "No methods found";
          listEl.appendChild(emptyMsg);
          updateRowHighlighting();
          return;
        }

        entries.forEach(([id, name]) => {
          const count = methodCounts.get(id) || 0;
          const isChecked = allowedMethods.has(id);

          const item = document.createElement("label");
          item.className = "proto-item" + (isChecked ? " selected" : "");
          item.setAttribute("role", "checkbox");
          item.setAttribute("tabindex", "0");

          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.checked = isChecked;

          const spanId = document.createElement("span");
          spanId.className = "proto-id";
          spanId.textContent = id;

          const spanName = document.createElement("span");
          spanName.className = "proto-name";
          spanName.textContent = name || "Unnamed";

          const badge = document.createElement("span");
          badge.className = "proto-badge";
          badge.textContent = count;

          item.appendChild(checkbox);
          item.appendChild(spanId);
          item.appendChild(spanName);
          item.appendChild(badge);
          listEl.appendChild(item);

          // Toggle handler
          function applyToggle(nextChecked) {
            if (nextChecked) {
              allowedMethods.add(id);
              saveAllowedMethods();
              updateRowHighlighting();
            } else {
              allowedMethods.delete(id);
              saveAllowedMethods();
              updateRowHighlighting();
            }
            checkbox.checked = allowedMethods.has(id);
            item.classList.toggle("selected", allowedMethods.has(id));
          }

          item.addEventListener("click", (e) => {
            if (e.target === checkbox) return;
            e.preventDefault();
            applyToggle(!allowedMethods.has(id));
          });

          checkbox.addEventListener("change", () => applyToggle(checkbox.checked));

          item.addEventListener("keydown", (e) => {
            if (e.key === " " || e.key === "Enter") {
              e.preventDefault();
              applyToggle(!allowedMethods.has(id));
            }
          });
        });

        updateRowHighlighting();
      }

      // =========================
      // Session Management
      // =========================
      function resetSessionCache() {
        rowFirstSeen.clear();
        methodCounts.clear();
        sessionStartTime = Date.now();
        console.log("âœ¦ Session cache cleared");
        renderStatisticsPanel();
        renderMethodFilterPanel();
      }

      // =========================
      // Global API
      // =========================
      window.__protoWatcher__ = {
        rowFirstSeen,
        methodCounts,
        allowedMethods,
        knownMethods,
        methodMap,
        resetSessionCache,
        renderMethodFilterPanel,
        renderStatisticsPanel
      };

      // =========================
      // Initialization
      // =========================
      $(document).ready(async function() {
        // Load complete method list from server first
        await loadAllMethodsFromServer();

        // Then render UI
        renderMethodFilterPanel();
        renderStatisticsPanel();

        // Periodic UI refresh (when not typing)
        setInterval(() => {
          if (!checkUserTyping()) {
            renderMethodFilterPanel();
            renderStatisticsPanel();
          }
        }, 10000); // Every 10 seconds
      });
    </script>
  </body>
</html>
